<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Robot Control (Touch Enabled)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- FIREBASE SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    
    <style>
        :root {
            --primary-color: #4f46e5;
            --secondary-color: #1f2937;
            --text-color: #f3f4f6;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
        }
        .container {
            max-width: 100vw;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }
        .joystick-canvas {
            background: var(--secondary-color);
            border: 2px solid var(--primary-color);
            border-radius: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            touch-action: none; /* Prevents scrolling/zooming while touching joystick */
            cursor: default; 
        }
        #status-indicator-ble, #status-indicator-webrtc {
            transition: background-color 0.5s, transform 0.3s;
        }
    </style>
</head>
<body>

<div class="container mx-auto">
    <h1 class="text-xl font-bold text-center text-primary-color mb-3">Mobile Robot Control</h1>
    <p class="text-center text-xs text-gray-400 mb-4">Control Robot (Pi) via WebRTC. BLE connection for ESP32 is not needed here as touch replaces it.</p>

    <!-- Connection Statuses -->
    <div class="bg-gray-800 p-3 rounded-xl shadow-lg mb-4 grid grid-cols-2 gap-3">
        
        <!-- BLE Status (Re-purposed for Control Mode) -->
        <div class="p-2">
            <div class="flex justify-between items-center mb-1">
                <h2 class="text-sm font-semibold text-indigo-300">J1: Pan/Tilt</h2>
                <div id="status-indicator-ble" class="w-3 h-3 rounded-full bg-blue-500"></div>
            </div>
            <div id="j1-display" class="text-xs text-gray-400">X: 0, Y: 0</div>
        </div>

        <!-- WebRTC Connection Panel -->
        <div class="p-2">
            <div class="flex justify-between items-center mb-1">
                <h2 class="text-sm font-semibold text-cyan-300">WebRTC Robot</h2>
                <div id="status-indicator-webrtc" class="w-3 h-3 rounded-full bg-red-500"></div>
            </div>
            <div id="status-message-webrtc" class="text-xs text-red-400">Disconnected.</div>
        </div>
    </div>

    <!-- Main Control Area: Joysticks -->
    <div class="flex-grow flex flex-col md:flex-row gap-4">

        <!-- J1 Pan/Tilt Control (Touch) -->
        <div class="bg-gray-800 p-2 rounded-xl shadow-lg flex flex-col items-center w-full md:w-1/2">
            <h3 class="text-sm font-semibold mb-2 text-indigo-400">J1: Pan/Tilt Control</h3>
            <canvas id="joystick-j1" class="joystick-canvas w-full aspect-square" data-key="j1"></canvas>
        </div>

        <!-- J2 Auxiliary Joystick -->
        <div class="bg-gray-800 p-2 rounded-xl shadow-lg flex flex-col items-center w-full md:w-1/2">
            <h3 class="text-sm font-semibold mb-2 text-cyan-400">J2: Aux Control</h3>
            <canvas id="joystick-j2" class="joystick-canvas w-full aspect-square" data-key="j2"></canvas>
            <div id="j2-display" class="mt-2 text-xs text-gray-400">X: 0, Y: 0</div>
        </div>
    </div>

    <!-- Buttons and Switches -->
    <div class="bg-gray-900 p-3 rounded-xl shadow-xl mt-4">
        <button id="start-webrtc" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 shadow-md">
            Start WebRTC Connection (Signal Robot)
        </button>
        <div class="grid grid-cols-4 gap-2 mt-3">
            <button id="switch-1" data-bit="0" class="switch-btn bg-gray-700 text-white font-semibold py-2 rounded-lg transition duration-150 hover:bg-gray-600">SW 1</button>
            <button id="switch-2" data-bit="1" class="switch-btn bg-gray-700 text-white font-semibold py-2 rounded-lg transition duration-150 hover:bg-gray-600">SW 2</button>
            <button id="switch-3" data-bit="2" class="switch-btn bg-gray-700 text-white font-semibold py-2 rounded-lg transition duration-150 hover:bg-gray-600">SW 3</button>
            <button id="switch-4" data-bit="3" class="switch-btn bg-gray-700 text-white font-semibold py-2 rounded-lg transition duration-150 hover:bg-gray-600">SW 4</button>
        </div>
    </div>
</div>

<script>
    // --- FIREBASE CONFIGURATION (REPLACE WITH YOUR KEYS!) ---
    const firebaseConfig = {
        apiKey: "YOUR_API_KEY",
        authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
        projectId: "YOUR_PROJECT_ID", // IMPORTANT
        storageBucket: "YOUR_PROJECT_ID.appspot.com",
        messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
        appId: "YOUR_APP_ID"
    };

    // Initialize Firebase and Firestore
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const CALLS_COLLECTION = 'robot_calls';
    const ROOM_ID = 'esp32_robot_room'; 
    let callDocRef = db.collection(CALLS_COLLECTION).doc(ROOM_ID);

    // --- Configuration & Globals ---
    const CONTROL_INTERVAL = 50; // ms (20 updates/sec for WebRTC)
    
    let pc = null;
    let dataChannel = null;
    let sendDataInterval = null;

    // Control data structure: (Touch input directly sets these values)
    let controlData = {
        j1: { x: 0, y: 0 },
        j2: { x: 0, y: 0 },
        sw: 0
    };

    const joystickState = {
        j1: { active: false, x: 0, y: 0, touchId: null },
        j2: { active: false, x: 0, y: 0, touchId: null }
    };
    
    const joystickVisuals = {
        j1: { canvas: 'joystick-j1', display: 'j1-display' },
        j2: { canvas: 'joystick-j2', display: 'j2-display' }
    };

    // --- Utility Functions ---
    
    function getCssVar(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function updateStatus(idSuffix, indicatorClass, message) {
        const indicator = document.getElementById(`status-indicator-${idSuffix}`);
        const msg = document.getElementById(`status-message-${idSuffix}`);
        
        // BLE indicator is repurposed for J1 status light
        if (idSuffix === 'ble') {
             indicator.className = `w-3 h-3 rounded-full ${indicatorClass} transform scale-100`;
        } else {
             indicator.className = `w-3 h-3 rounded-full ${indicatorClass} transform scale-100`;
             msg.textContent = message;
             msg.className = `text-xs ${indicatorClass.replace('bg-', 'text-')}`;
        }
    }
    
    // --- WebRTC Logic (Output to Raspberry Pi) ---

    async function startWebRTC() {
        if (pc && (pc.connectionState === 'connected' || pc.connectionState === 'connecting')) return;
        
        updateStatus('webrtc', 'bg-yellow-500', 'Starting Signaling...');
        const startButton = document.getElementById('start-webrtc');
        startButton.disabled = true;

        // Clear previous room data from Firestore
        await callDocRef.delete().catch(e => console.log("No existing room to delete."));
        
        pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });
        
        // 1. Setup ICE Candidate handler (Caller)
        const offerCandidatesCollection = callDocRef.collection('offerCandidates');
        pc.onicecandidate = event => {
            if (event.candidate) {
                offerCandidatesCollection.add(event.candidate.toJSON());
            }
        };

        // 2. Data Channel Setup
        dataChannel = pc.createDataChannel("controls");
        dataChannel.onopen = () => {
            console.log("WebRTC Data Channel opened");
            updateStatus('webrtc', 'bg-green-500', 'CONNECTED! Sending controls.');
            sendDataInterval = setInterval(sendControlData, CONTROL_INTERVAL);
            startButton.textContent = 'Disconnect WebRTC';
            startButton.disabled = false;
            startButton.classList.remove('bg-cyan-600', 'hover:bg-cyan-700');
            startButton.classList.add('bg-red-600', 'hover:bg-red-700');
        };
        dataChannel.onclose = () => {
            disconnectWebRTC();
        };
        dataChannel.onerror = (error) => {
            console.error("WebRTC Data Channel Error:", error);
            disconnectWebRTC();
        };

        // 3. Connection State Change
        pc.onconnectionstatechange = () => {
            console.log(`WebRTC state: ${pc.connectionState}`);
            if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                disconnectWebRTC();
            } else if (pc.connectionState === 'connecting') {
                updateStatus('webrtc', 'bg-yellow-500', 'Connecting...');
            }
        };
        
        // 4. Create Offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        // 5. Write Offer to Firestore
        const offerData = {
            offer: { sdp: offer.sdp, type: offer.type }
        };
        await callDocRef.set(offerData);

        updateStatus('webrtc', 'bg-blue-500', 'Offer sent. Waiting...');
        startButton.textContent = 'WebRTC Connecting...';

        // 6. Listen for Answer (Caller)
        callDocRef.onSnapshot(async snapshot => {
            const data = snapshot.data();
            if (data && data.answer && !pc.currentRemoteDescription) {
                console.log('Received Answer:', data.answer);
                const answerDescription = new RTCSessionDescription(data.answer);
                await pc.setRemoteDescription(answerDescription);
                listenForAnswerCandidates(); 
            }
        });
    }
    
    function listenForAnswerCandidates() {
        const answerCandidatesCollection = callDocRef.collection('answerCandidates');
        answerCandidatesCollection.onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
                if (change.type === 'added') {
                    const candidate = new RTCIceCandidate(change.doc.data());
                    await pc.addIceCandidate(candidate);
                }
            });
        });
    }

    async function disconnectWebRTC() {
        clearInterval(sendDataInterval);
        if (pc) {
            pc.close();
        }
        updateStatus('webrtc', 'bg-red-500', 'Disconnected.');
        const startButton = document.getElementById('start-webrtc');
        startButton.textContent = 'Start WebRTC Connection (Signal Robot)';
        startButton.disabled = false;
        startButton.classList.remove('bg-red-600', 'hover:bg-red-700');
        startButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
        
        // Clean up signaling data when the browser disconnects intentionally
        await callDocRef.delete().catch(e => console.log("Room already deleted."));
    }

    function sendControlData() {
        if (dataChannel && dataChannel.readyState === 'open') {
            
            // Map the joystick position (pixels) to the control range (-127 to 127)
            const mapJoystickToRange = (state) => {
                const canvas = document.getElementById(joystickVisuals[state].canvas);
                const maxDisplacement = canvas.width / 2 * 0.45;
                
                // X: Map from -maxDisplacement to +maxDisplacement -> -127 to 127
                const x = Math.round(state.x / maxDisplacement * 127);
                // Y: Map from -maxDisplacement to +maxDisplacement -> -127 to 127
                // Note: Canvas Y is inverted relative to robot movement
                const y = Math.round(-state.y / maxDisplacement * 127); 
                
                // Clamp values to the safe range
                return { 
                    x: Math.max(-127, Math.min(127, x)), 
                    y: Math.max(-127, Math.min(127, y)) 
                };
            };
            
            const j1_mapped = mapJoystickToRange(joystickState.j1);
            const j2_mapped = mapJoystickToRange(joystickState.j2);
            
            // Update display
            document.getElementById(joystickVisuals.j1.display).textContent = `X: ${j1_mapped.x}, Y: ${j1_mapped.y}`;
            document.getElementById(joystickVisuals.j2.display).textContent = `X: ${j2_mapped.x}, Y: ${j2_mapped.y}`;
            
            const payload = {
                j1: j1_mapped,
                j2: j2_mapped,
                sw: controlData.sw
            };
            
            try {
                // Send JSON payload to the Raspberry Pi
                dataChannel.send(JSON.stringify(payload));
            } catch (e) {
                console.warn("Failed to send data:", e);
            }
        }
    }


    // --- Touch/Visualization Logic ---
    
    function drawJoystick(id, x = 0, y = 0) {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext('2d');
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const maxRadius = Math.min(centerX, centerY) * 0.45; // Max displacement
        const stickRadius = maxRadius * 0.5; 
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw boundary circle
        ctx.beginPath();
        ctx.arc(centerX, centerY, maxRadius * 1.5, 0, Math.PI * 2, false);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = getCssVar('--primary-color'); 
        ctx.stroke();

        // Draw center dot
        ctx.beginPath();
        ctx.arc(centerX, centerY, 3, 0, Math.PI * 2, false);
        ctx.fillStyle = '#fff';
        ctx.fill();
        
        // Draw joystick stick
        const stickX = centerX + x;
        const stickY = centerY + y;
        
        ctx.beginPath();
        ctx.arc(stickX, stickY, stickRadius, 0, Math.PI * 2, false);
        ctx.fillStyle = getCssVar('--primary-color');
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.stroke();
    }

    function initJoystick(id) {
        const canvas = document.getElementById(id);
        
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            drawJoystick(id, 0, 0);
        }

        const resizeObserver = new ResizeObserver(resizeCanvas);
        resizeObserver.observe(canvas);
        resizeCanvas();
    }
    
    // --- Touch Handlers (Core Mobile Control) ---
    
    function getJoystickState(id) {
        return joystickState[document.getElementById(id).getAttribute('data-key')];
    }
    
    function handleStart(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        
        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const canvas = touch.target;
            const stateKey = canvas.getAttribute('data-key');
            
            if (!joystickState[stateKey].active) {
                const rect = canvas.getBoundingClientRect();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = canvas.width / 2 * 0.45;
                
                // Start position relative to the center of the canvas
                const startX = touch.clientX - rect.left - centerX;
                const startY = touch.clientY - rect.top - centerY;
                
                // If the initial touch is inside the max movement circle
                if (Math.hypot(startX, startY) <= maxRadius * 1.5) { 
                    joystickState[stateKey] = {
                        active: true,
                        x: startX,
                        y: startY,
                        touchId: touch.identifier
                    };
                    updateStatus('ble', 'bg-green-500', ''); 
                    handleMove({ changedTouches: [touch], target: canvas }); // Process first move
                }
            }
        }
    }

    function handleMove(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        
        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const canvas = touch.target;
            const stateKey = canvas.getAttribute('data-key');
            const state = joystickState[stateKey];
            
            if (state.active && state.touchId === touch.identifier) {
                const rect = canvas.getBoundingClientRect();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = canvas.width / 2 * 0.45;
                
                let newX = touch.clientX - rect.left - centerX;
                let newY = touch.clientY - rect.top - centerY;

                // Clamp the stick position to the maximum radius
                const distance = Math.hypot(newX, newY);
                if (distance > maxRadius) {
                    newX = (newX / distance) * maxRadius;
                    newY = (newY / distance) * maxRadius;
                }
                
                state.x = newX;
                state.y = newY;
                drawJoystick(canvas.id, newX, newY);
            }
        }
    }

    function handleEnd(e) {
        e.preventDefault();
        const touches = e.changedTouches;
        
        for (let i = 0; i < touches.length; i++) {
            const touch = touches[i];
            const stateKey = touch.target.getAttribute('data-key');
            const state = joystickState[stateKey];
            
            if (state.active && state.touchId === touch.identifier) {
                // Reset stick to center (zero input)
                state.active = false;
                state.x = 0;
                state.y = 0;
                state.touchId = null;
                drawJoystick(touch.target.id, 0, 0);
            }
        }
        
        // If both joysticks are inactive, show neutral status
        if (!joystickState.j1.active && !joystickState.j2.active) {
            updateStatus('ble', 'bg-blue-500', ''); 
        }
    }

    // --- Switch Logic ---
    function toggleSwitch(event) {
        const button = event.currentTarget;
        const bit = parseInt(button.getAttribute('data-bit'));
        const mask = 1 << bit;
        
        // Toggle the bit
        controlData.sw ^= mask; 
        
        // Update styling
        if (controlData.sw & mask) {
            button.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            button.classList.add('bg-green-500', 'hover:bg-green-600');
        } else {
            button.classList.remove('bg-green-500', 'hover:bg-green-600');
            button.classList.add('bg-gray-700', 'hover:bg-gray-600');
        }
    }

    // --- Initialization ---

    document.addEventListener('DOMContentLoaded', () => {
        initJoystick('joystick-j1');
        initJoystick('joystick-j2');
        
        // Attach WebRTC listener
        document.getElementById('start-webrtc').addEventListener('click', () => {
             // If already connected, disconnect; otherwise, start.
            if (dataChannel && dataChannel.readyState === 'open') {
                disconnectWebRTC();
            } else {
                startWebRTC();
            }
        });
        
        // Attach touch listeners to the canvases
        document.getElementById('joystick-j1').addEventListener('touchstart', handleStart, false);
        document.getElementById('joystick-j2').addEventListener('touchstart', handleStart, false);
        
        document.getElementById('joystick-j1').addEventListener('touchmove', handleMove, false);
        document.getElementById('joystick-j2').addEventListener('touchmove', handleMove, false);
        
        document.getElementById('joystick-j1').addEventListener('touchend', handleEnd, false);
        document.getElementById('joystick-j2').addEventListener('touchend', handleEnd, false);

        // Attach switch listeners
        document.querySelectorAll('.switch-btn').forEach(button => {
            button.addEventListener('click', toggleSwitch);
        });
        
        // Initial neutral status
        updateStatus('ble', 'bg-blue-500', '');
    });
</script>

</body>
</html>